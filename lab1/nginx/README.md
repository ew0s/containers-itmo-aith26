## Лабораторная работа № 1 — nginx + VTS

Написать два Dockerfile – плохой и хороший. Написать две плохие практики по использованию контейнеров Описание Плохой Dockerfile должен запускаться и работать корректно, но в нём должно быть не менее 3 “bad practicesˮ. В хорошем они должны быть исправлены. В Readme описать все плохие практики из кода Dockerfile и почему они плохие, как они были исправлены в хорошем Dockerfile, а также две плохие практики по использованию этого контейнера. Написать два случая, когда НЕ стоит использовать контейнеры в целом Монтирование volume в контейнере - обязательно.

Цель: показать контраст между плохим и хорошим Dockerfile, описать практики эксплуатации контейнера и зафиксировать ситуации, когда контейнеризация не подходит.

Репозиторий содержит:

- `Dockerfile.bad` — намеренно «плохой» образ с рабочим Nginx + VTS, но с набором анти‑паттернов.
- `Dockerfile.good` — production-ориентированный образ c multi-stage сборкой, healthcheck и безопасным запуском.
- `nginx.conf` — конфигурация, включающая HTML/JSON/Prometheus-эндпоинты VTS.

---

### Как проверить

```bash
cd lab1/nginx

# 1. Собрать оба образа
docker build -f Dockerfile.bad -t nginx-vts:bad .
docker build -f Dockerfile.good -t nginx-vts:good .

# 2. Создать том под логи
docker volume create nginx-logs

# 3. Запустить контейнеры (порты разведены, чтобы сравнивать параллельно)
docker run -d --rm --name nginx-vts-bad \
  -p 8080:80 -v nginx-logs:/var/log/nginx nginx-vts:bad

docker run -d --rm --name nginx-vts-good \
  -p 8081:80 -v nginx-logs:/var/log/nginx nginx-vts:good

# 4. Проверить эндпоинты VTS
curl http://localhost:8081/status
curl http://localhost:8081/status/format/json
curl http://localhost:8081/status/format/prometheus
```

Логи из обоих контейнеров можно посмотреть через `docker run --rm -it -v nginx-logs:/logs busybox sh -c "ls -l /logs"`.

---

### Почему `Dockerfile.bad` плохой

1. **`FROM nginx:latest`** — пересборка завтра может стянуть несовместимую версию nginx (недетерминированность, неожиданные регрессии).
2. **Все RUN в одном слое** — build-инструменты (`gcc`, `git`, `make`, `curl` и др.) оказываются в runtime-образе, что утяжеляет и расширяет поверхность атаки.
3. **Модуль клонируется «с головы»** — `git clone` без фиксации тега/коммита, поэтому каждый билд может собирать разный VTS.
4. **Сборка происходит в runtime-образе** — нарушает separation of concerns и лишает нас преимуществ multi-stage (кэш, размер, безопасность).
5. **Процесс запускается от root** — в случае компрометации вор получает полный доступ внутри контейнера.
6. **Нет объявления `VOLUME` и инструкции по монтированию** — логи исчезают вместе с контейнером, нарушается принцип stateless.
7. **Не чистится `/tmp`** — исходники и артефакты навсегда остаются в последнем слое, ещё больше раздувая образ.

---

### Что сделано в `Dockerfile.good`

- **Multi-stage сборка**: первый шаг (`builder`) собирает Nginx с модулем VTS, финальный слой получает только бинарники и конфиги.
- **Фиксированные версии**: `nginx:1.27-alpine`, `ARG VTS_VERSION=v0.1.18`, загрузка тарболла строго по версии из `nginx -v`.
- **Чистый runtime**: build-зависимости удаляются ещё в builder-слое, финальный образ содержит только runtime-пакеты.
- **Непривилегированный запуск**: создаётся пользователь `nginx`, бинарнику назначается capability `cap_net_bind_service`, затем контейнер стартует как `USER nginx`.
- **Наблюдаемость**: добавлен `HEALTHCHECK`, VTS выдаёт HTML/JSON/Prometheus, логи перенаправлены в STDOUT/STDERR и продекларированы через `VOLUME`.
- **Документация образа**: OCI LABEL с описанием и ссылкой на репозиторий, `STOPSIGNAL SIGQUIT` для graceful shutdown.
- **Сопутствующие практики**: каталог `/var/run/nginx` создаётся с нужными правами, зависимости сгруппированы, сборка максимально идемпотентна (см. `BEST_PRACTICES_TEMPLATE.md`).

---

### Плохие практики и их исправления

| № | Что плохо в `Dockerfile.bad` | Почему это критично | Как исправлено в `Dockerfile.good` |
|---|------------------------------|---------------------|------------------------------------|
| 1 | `FROM nginx:latest` | Нельзя воспроизвести билд, возможны несовместимые апдейты | Жёстко задан `nginx:1.27-alpine`, версия VTS вынесена в `ARG` |
| 2 | Все слои выполняются подряд в одном образе | Build-инструменты «утекают» в runtime и увеличивают размер | Multi-stage (`builder` + `runtime`), в финальный слой копируются только артефакты |
| 3 | `git clone` без тега/коммита | Модуль VTS может поменяться в любой момент | `ARG VTS_VERSION` + `--depth 1 --branch v0.1.18`, сборка строго по нужной версии |
| 4 | Build ведётся прямо в runtime-образе | Нет разделения окружений, грязный кэш | Сборка проходит в отдельном слое, финальный образ чистый |
| 5 | Процесс остаётся root | Компрометация nginx = полный доступ | Создан пользователь `nginx`, бинарник получил `cap_net_bind_service`, контейнер запускается как `USER nginx` |
| 6 | Нет `VOLUME` и инструкции по монтированию | Логи исчезают при удалении контейнера | Добавлен `VOLUME ["/var/log/nginx"]` и обязательный `-v nginx-logs:/var/log/nginx` при запуске |
| 7 | Не чистится `/tmp`, нет удаления deps | Образ пухнет, внутри остаются исходники и secrets | Builder очищает `/tmp/src`, удаляет `.build-deps`, runtime получает только нужные файлы |

---

### Плохие практики эксплуатации этого контейнера

1. **Запускать с `--privileged` или пробрасывать Docker socket внутрь** — контейнер получает root-доступ к хосту, что полностью нивелирует все меры безопасности dockerized‑приложения.
2. **Игнорировать volume для логов** — запуск `docker run …` без `-v nginx-logs:/var/log/nginx` приведёт к потере истории запросов, невозможности расследований и нарушит требования задания.

---

### Когда лучше не использовать контейнеры

1. **Жёстко привязанные к железу нагрузки** — низкоуровневые сетевые аплаиансы, требующие SR-IOV, USB или специализированных FPGA/GPU режимов, где слой контейнеризации мешает получить нужные capability.
2. **Монолитные, сильно stateful-системы с тяжёлым I/O** — например, большие СУБД с массивными shard'ами или виртуализация рабочего стола. Им нужны стабильные ядра, контроль над storage/NUMA и другой инструментарий (bare metal или полноценные VM).